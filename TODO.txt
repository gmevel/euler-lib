- use a test tool!
- grep 'TODO|FIXME' *.ml *.mli
- Arith.valuation_of_2:
  + reduce the step-length from 8 to 4, so that precomputed values fit in a
    single 31-bit integer (step=4: 2×8=16 bits; step=5: 3×16=48 bits)
  + compare (benchmark) with just using Arith.log2sup, in any case leave a comment
- optimize Modular.mul
- micro-optimize (branchless code) Modular base operations
- micro-optimize branches by putting the common case first?
- add inlining hints, turn Modular.to_int into external identity, etc.
- Modular.of_int: add a test for the common scenario where no modulo is needed?
  needs benchmarking
- improve interface for computing multiplicative orders modulo [m]:
  having to pass factorizations explicitly is annoying;
  use a cache for already-copmuted factorizations?
- improve [Primes.iter_primes]:
  + usability: take an optional 2nd callback, [do_composite]
- have a faster [Primes.gen_primes]:
    (once OCaml supports algebraic effects, this might become possible
    by turning the iterator [Primes.iter_primes] into a sequence)
- improve [Primes.factorizing_sieve]:
  + usability: take more calbacks as arguments
  + store the factorizations implicitly
  + cull composite numbers by ascending prime powers (avoid repeated divisions)
- use a bitset for storing the sets of primes up to 100 or 10_000, and see
  whether there is any benefit from it
- clean and document the Farey module
- implement a solver for Pell’s equations: see TODO/Pell.ml
- implement something about Pythagorean triples: see TODO/pythagorean-triples.txt
- implement something about continued fractions
  + might be used to improve the Pell’s equation solver (finding the fundamental solution)
