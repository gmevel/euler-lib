<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Arith (euler.Euler.Arith)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">euler</a> &#x00BB; <a href="../index.html">Euler</a> &#x00BB; Arith</nav><header class="odoc-preamble"><h1>Module <code><span>Euler.Arith</span></code></h1><p>Arithmetic on overflowing integers.</p><p>All operations defined here act on overflowing integers. An overflowing integer is any native integer (type <code>int</code>) except <code>Stdlib.min_int</code>. Otherwise said, it is an integer whose absolute value is at most <a href="#val-max_int"><code>max_int</code></a> = 2<sup><code>int_size</code>−1</sup> − 1, implying that the minimum value is <a href="#val-min_int"><code>min_int</code></a> = −<a href="#val-max_int"><code>max_int</code></a> = −2<sup><code>int_size</code>−1</sup> + 1 = <code>Stdlib.min_int</code>+1 (!). This makes the range of overflowing integers symmetrical, so that computing the opposite <code>( ~- )</code> or the absolute value <code>abs</code> never overflows (the presence of an additional value 2<sup><code>int_size</code>−1</sup> being arbitrarily interpreted as a negative value fits the modulo semantics of integers, but is alien to an overflowing semantics).</p><p>Incidentally, this allows to use <code>Stdlib.min_int</code> as a special value, for example to signal that an overflow occurred. However in this library we rather raise an exception for that purpose. All functions in this library may fail when given <code>Stdlib.min_int</code> where an overflowing integer was expected.</p><p>All operations defined here either are free of overflows, or raise <code>Overflow</code> when their <em>result</em> would exceed the range of overflowing integers (and only in that case). Functions which can overflow are signaled explicitly in this documentation.</p><p>Functions in this library may raise <code>Assert_failure</code>, instead of the more traditional <code>Invalid_argument</code>, when some precondition is not met. This is not necessarily signaled in this documentation, but all preconditions are stated in the English description of functions. However, we still treat division‐by‐zero differently than other preconditions; for that we raise <code>Division_by_zero</code>, and signal it in this documentation.</p><p>As much as possible, time and space complexities are indicated (time complexities are termed as a count of machine-arithmetic operations). If absent, constant time or constant space is implied.</p><p>By opening it, this module can mostly be used as a drop-in replacement for Stdlib arithmetic operations. This allows lightweight notations and avoids accidental uses of overflow-unsafe Stdlib operations. Beware of the following changes:</p><ul><li><a href="#val-min_int"><code>min_int</code></a> has a different value (as explained);</li><li><a href="#val-min"><code>min</code></a>, <a href="#val-max"><code>max</code></a> and <a href="#val-compare"><code>compare</code></a> are monomorphic functions for type <code>int</code>, instead of polymorphic functions;</li><li><a href="#val-(**)"><code>(**)</code></a> is redefined as the <em>integer</em> exponentation (the floating-point exponentiation is available as <a href="#val-(**.)"><code>(**.)</code></a>);</li><li><a href="#val-(/)"><code>(/)</code></a> is restricted to an <em>exact</em> division (a possibly-rounded division is available as <a href="#val-(//)"><code>(//)</code></a>, which differs from <code>Stdlib.(/)</code> in that it does an Euclidean division);</li><li><a href="#val-(mod)"><code>(mod)</code></a> is redefined as the <em>Euclidean</em> remainder.</li></ul></header><nav class="odoc-toc"><ul><li><a href="#base-operations">Base operations</a></li><li><a href="#exponentiation-and-logarithms">Exponentiation and logarithms</a></li><li><a href="#roots">Roots</a></li><li><a href="#divisors-and-multiples">Divisors and multiples</a></li><li><a href="#binomial-coefficients">Binomial coefficients</a></li><li><a href="#bit-manipulation">Bit manipulation</a></li><li><a href="#randomness">Randomness</a></li><li><a href="#sequences">Sequences</a></li><li><a href="#operators">Operators</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-max_int"><a href="#val-max_int" class="anchor"></a><code><span><span class="keyword">val</span> max_int : int</span></code></div><div class="spec-doc"><p>The largest representable integer. This is <code>Stdlib.max_int</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-min_int"><a href="#val-min_int" class="anchor"></a><code><span><span class="keyword">val</span> min_int : int</span></code></div><div class="spec-doc"><p>The smallest representable integer. This is the opposite of <code>max_int</code>, and differs from <code>Stdlib.min_int</code>.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Overflow"><a href="#exception-Overflow" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Overflow</span></span></code></div><div class="spec-doc"><p>Raised when the integer result of an operation is not representable.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Division_not_exact"><a href="#exception-Division_not_exact" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Division_not_exact</span></span></code></div><div class="spec-doc"><p>Raised when an operation was expected to perform an exact division but the dividend was not a multiple of the divisor.</p></div></div><h3 id="base-operations"><a href="#base-operations" class="anchor"></a>Base operations</h3><div class="odoc-spec"><div class="spec value anchored" id="val-sign"><a href="#val-sign" class="anchor"></a><code><span><span class="keyword">val</span> sign : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>sign a</code> is +1 if <code>a</code> is positive, 0 if it is null, and −1 if it is negative.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul_sign"><a href="#val-mul_sign" class="anchor"></a><code><span><span class="keyword">val</span> mul_sign : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>mul_sign s n</code> is <code>n</code> if <code>s</code> is non-negative and −<code>n</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul_sign0"><a href="#val-mul_sign0" class="anchor"></a><code><span><span class="keyword">val</span> mul_sign0 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>mul_sign0 s n</code> is <code>n</code> if <code>s</code> is positive, 0 if it is null, and −<code>n</code> if it is negative. In other words, it is equivalent to <code>mul (sign s) a</code>, but much faster.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-abs"><a href="#val-abs" class="anchor"></a><code><span><span class="keyword">val</span> abs : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Absolute value. By contrast with <code>Stdlib.abs</code>, it cannot overflow.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-min"><a href="#val-min" class="anchor"></a><code><span><span class="keyword">val</span> min : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Minimum of two integers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-max"><a href="#val-max" class="anchor"></a><code><span><span class="keyword">val</span> max : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Maximum of two integers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare a b</code> returns <code>0</code> when <code>a</code> is equal to <code>b</code>, a negative integer when <code>a</code> is smaller than <code>b</code>, and a positive integer when <code>a</code> is greater than <code>b</code>. It is the same as <code>Stdlib.compare</code> but much faster.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal a b</code> returns <code>true</code> when <code>a</code> is equal to <code>b</code>, <code>false</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pred"><a href="#val-pred" class="anchor"></a><code><span><span class="keyword">val</span> pred : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>pred n</code> is <code>n</code>−1.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-succ"><a href="#val-succ" class="anchor"></a><code><span><span class="keyword">val</span> succ : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>succ n</code> is <code>n</code>+1.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-opp"><a href="#val-opp" class="anchor"></a><code><span><span class="keyword">val</span> opp : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Integer opposite. By contrast with <code>Stdlib.(~-)</code>, it cannot overflow.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Overflowing integer addition.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Overflowing integer subtraction.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sum_of_seq"><a href="#val-sum_of_seq" class="anchor"></a><code><span><span class="keyword">val</span> sum_of_seq : <span><span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Overflowing integer summation. Unlike a naive iteration of <a href="#val-add"><code>add</code></a>, this succeeds as long as the result is representable, even when partial sums overflow. Beware that the input sequence is read twice. If that is undesirable, use <code>Seq.memoize</code> (OCaml 4.14). <b>Complexity:</b> time 𝒪(<i>n</i>), space 𝒪(1) where <i>n</i> is the length of the sequence.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span><span class="keyword">val</span> sum : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Same as <a href="#val-sum_of_seq"><code>sum_of_seq</code></a> but where the input sequence is a list.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span><span class="keyword">val</span> mul : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Overflowing integer multiplication.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul2"><a href="#val-mul2" class="anchor"></a><code><span><span class="keyword">val</span> mul2 : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>mul2 a</code> is equivalent to <code>mul 2 a</code> but much faster.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul_pow2"><a href="#val-mul_pow2" class="anchor"></a><code><span><span class="keyword">val</span> mul_pow2 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>mul_pow2 k a</code> is equivalent to <code>mul (pow2 k) a</code> but much faster.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prod_of_seq"><a href="#val-prod_of_seq" class="anchor"></a><code><span><span class="keyword">val</span> prod_of_seq : <span><span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Overflowing n-ary multiplication. Unlike a naive iteration of <a href="#val-mul"><code>mul</code></a>, this succeeds as long as the result is representable even when partial products overflow (this situation only happens when one of the operands is zero). Every operand is read at most once; when an operand is zero, following operands are not read. <b>Complexity:</b> time 𝒪(<i>n</i>), space 𝒪(1) where <i>n</i> is the length of the sequence.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prod"><a href="#val-prod" class="anchor"></a><code><span><span class="keyword">val</span> prod : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Same as <a href="#val-prod_of_seq"><code>prod_of_seq</code></a> but where the input sequence is a list.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-div_exact"><a href="#val-div_exact" class="anchor"></a><code><span><span class="keyword">val</span> div_exact : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Exact integer division. By contrast with <code>Stdlib.(/)</code>, it cannot overflow.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when the divisor is null.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_not_exact</span> <p>when the dividend is not a multiple of the divisor.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sdiv"><a href="#val-sdiv" class="anchor"></a><code><span><span class="keyword">val</span> sdiv : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>sdiv a b</code> is the “signed” division of <code>a</code> by <code>b</code>; it returns <code>(q, r)</code> such that <code>a</code> = <code>b</code>×<code>q</code> + <code>r</code> and |<code>r</code>| &lt; |<code>a</code>| and <code>r</code> is of the same sign as <code>a</code>.</p><p>This is the standard library’s division. However, using <code>sdiv</code> is better than computing both <code>Stdlib.(a / b)</code> and <code>Stdlib.(a mod b)</code> separately, because <code>sdiv</code> spares one machine division, which is much more costly than a multiplication.</p><p><code>sdiv</code> is slightly faster than <a href="#val-ediv"><code>ediv</code></a>, so it is also useful when we don’t need the remainder to be positive or when we know that <code>a</code> ≥ 0.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>b</code> is null.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ediv"><a href="#val-ediv" class="anchor"></a><code><span><span class="keyword">val</span> ediv : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>ediv a b</code> is the Euclidean division of <code>a</code> by <code>b</code>; it returns <code>(q, r)</code> such that <code>a</code> = <code>b</code>×<code>q</code> + <code>r</code> and 0 ≤ <code>r</code> &lt; <code>b</code>. By contrast with <a href="#val-sdiv"><code>sdiv</code></a>, the remainder is never negative.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>b</code> is null.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equo"><a href="#val-equo" class="anchor"></a><code><span><span class="keyword">val</span> equo : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>equo a b</code> is the quotient of the Euclidean division of <code>a</code> by <code>b</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>b</code> is null.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-erem"><a href="#val-erem" class="anchor"></a><code><span><span class="keyword">val</span> erem : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>erem a b</code> is the remainder of the Euclidean division of <code>a</code> by <code>b</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>b</code> is null.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ediv2"><a href="#val-ediv2" class="anchor"></a><code><span><span class="keyword">val</span> ediv2 : <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equo2"><a href="#val-equo2" class="anchor"></a><code><span><span class="keyword">val</span> equo2 : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-erem2"><a href="#val-erem2" class="anchor"></a><code><span><span class="keyword">val</span> erem2 : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><p>Faster alternatives when the divisor is 2.</p><div class="odoc-spec"><div class="spec value anchored" id="val-ediv_pow2"><a href="#val-ediv_pow2" class="anchor"></a><code><span><span class="keyword">val</span> ediv_pow2 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equo_pow2"><a href="#val-equo_pow2" class="anchor"></a><code><span><span class="keyword">val</span> equo_pow2 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-erem_pow2"><a href="#val-erem_pow2" class="anchor"></a><code><span><span class="keyword">val</span> erem_pow2 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><p>Faster alternatives when the divisor is a power of 2. <code>ediv_pow2 a k</code> is equivalent to <code>ediv a (pow2 k)</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the remainder overflows (happens only when <code>a</code> &lt; 0 and <code>pow2 k</code> overflows; <code>equo_pow2</code> is not affected).</p></li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-mul_div_exact"><a href="#val-mul_div_exact" class="anchor"></a><code><span><span class="keyword">val</span> mul_div_exact : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>mul_div_exact a b c</code> computes <code>a</code>×<code>b</code>∕<code>c</code> when <code>c</code> does divide <code>a</code>×<code>b</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>c</code> is null.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_not_exact</span> <p>when <code>c</code> does not divide <code>a</code>×<code>b</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul_ediv"><a href="#val-mul_ediv" class="anchor"></a><code><span><span class="keyword">val</span> mul_ediv : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>mul_ediv a b c</code> computes the Euclidean division of <code>a</code>×<code>b</code> by <code>c</code>, even when the intermediate product would overflow.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>c</code> is null.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the quotient overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul_equo"><a href="#val-mul_equo" class="anchor"></a><code><span><span class="keyword">val</span> mul_equo : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>mul_equo a b c</code> is the quotient of the Euclidean division of <code>a</code>×<code>b</code> by <code>c</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>c</code> is null.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul_erem"><a href="#val-mul_erem" class="anchor"></a><code><span><span class="keyword">val</span> mul_erem : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>mul_erem a b c</code> is the remainder of the Euclidean division of <code>a</code>×<code>b</code> by <code>c</code>. It cannot overflow.</p><p>If you are interested in modular arithmetic, see also <a href="../Modular/index.html#val-mul"><code>Modular.mul</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>c</code> is null.</p></li></ul></div></div><h3 id="exponentiation-and-logarithms"><a href="#exponentiation-and-logarithms" class="anchor"></a>Exponentiation and logarithms</h3><div class="odoc-spec"><div class="spec value anchored" id="val-pow"><a href="#val-pow" class="anchor"></a><code><span><span class="keyword">val</span> pow : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Overflowing integer exponentiation. <code>pow a n</code> is <code>a</code> to the power <code>n</code>, provided that <code>n</code> is non‐negative. Of course, 0<sup>0</sup> = 1. <b>Complexity:</b> 𝒪(log(<code>n</code>)) integer multiplications.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pow2"><a href="#val-pow2" class="anchor"></a><code><span><span class="keyword">val</span> pow2 : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>pow2 n</code> is equivalent to <code>pow 2 n</code>, but much faster. <b>Complexity:</b> 𝒪(1).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-powm1"><a href="#val-powm1" class="anchor"></a><code><span><span class="keyword">val</span> powm1 : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>powm1 n</code> is equivalent to <code>pow (-1) (abs n)</code>, but much faster. <code>n</code> may be negative. <b>Complexity:</b> 𝒪(1).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ilog"><a href="#val-ilog" class="anchor"></a><code><span><span class="keyword">val</span> ilog : <span>?base:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>ilog ~base n</code> is the logarithm of <code>n</code> in base <code>base</code> rounded towards zero, provided that <code>base</code> is at least 2 and that <code>n</code> is non‐negative. In other words, it returns ⌊ln(<code>n</code>)∕ln(<code>base</code>)⌋, This is the unique integer <code>k</code> such that <code>base</code><sup><code>k</code></sup> ≤ <code>n</code> &lt; <code>base</code><sup><code>k</code>+1</sup>. This is a relatively slow operation in general, but it is specially optimized for bases 2, 16, 64, 10 and 60. The default base is 10. <b>Complexity:</b> 𝒪(log(log(<code>n</code>))) integer multiplications.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>−1 when <code>n</code> = 0.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ilog2"><a href="#val-ilog2" class="anchor"></a><code><span><span class="keyword">val</span> ilog2 : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>ilog2 n</code> is equivalent to <code>ilog ~base:2 n</code> but faster.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>−1 when <code>n</code> = 0.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ilogsup"><a href="#val-ilogsup" class="anchor"></a><code><span><span class="keyword">val</span> ilogsup : <span>?base:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>ilogsup ~base n</code> is the number of digits of <code>n</code> in base <code>base</code>, provided that <code>base</code> is at least 2 and that <code>n</code> is non‐negative. It is equal to ⌈ln(<code>n</code>+1)∕ln(<code>base</code>)⌉ and also (when <code>n</code> is not null) to ⌊ln(<code>n</code>)∕ln(<code>base</code>)⌋ + 1. This is the unique integer <code>k</code> such that <code>base</code><sup><code>k</code>−1</sup> ≤ <code>n</code> &lt; <code>base</code><sup><code>k</code></sup>. As for <a href="#val-ilog"><code>ilog</code></a>, this is relatively slow but it is fast for bases 2, 16, 64, 10 and 60. The default base is 10. <b>Complexity:</b> 𝒪(log(log(<code>n</code>))) integer multiplications.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>0 when <code>n</code> = 0.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ilog2sup"><a href="#val-ilog2sup" class="anchor"></a><code><span><span class="keyword">val</span> ilog2sup : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>ilog2sup n</code> is equivalent to <code>ilogsup ~base:2 n</code> but faster.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>0 when <code>n</code> = 0.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_pow"><a href="#val-is_pow" class="anchor"></a><code><span><span class="keyword">val</span> is_pow : <span>?base:int <span class="arrow">&#45;&gt;</span></span> <span>?exp:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_pow ~base ~exp n</code> is true if and only if <code>n</code> = <code>base</code><sup><code>exp</code></sup>. When <code>exp</code> is omitted, <code>is_kth_pow ~base n</code> says whether <code>n</code> is some power of <code>base</code>. When <code>exp</code> is provided, it is equivalent to <a href="#val-is_kth_pow"><code>is_kth_pow</code></a><code> ~k:exp ~root:base n</code>. The default base is 10.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_pow2"><a href="#val-is_pow2" class="anchor"></a><code><span><span class="keyword">val</span> is_pow2 : <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_pow2 n</code> is equivalent to <code>is_pow ~base:2 n</code>, but much faster.</p></div></div><h3 id="roots"><a href="#roots" class="anchor"></a>Roots</h3><div class="odoc-spec"><div class="spec value anchored" id="val-kth_root"><a href="#val-kth_root" class="anchor"></a><code><span><span class="keyword">val</span> kth_root : <span>k:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>kth_root ~k n</code> is the integer <code>k</code><sup>th</sup> root of <code>n</code>, rounded towards zero. In other words, it is <code>sign n × r</code> where <code>r</code> is the greatest integer such that <code>r</code><sup><code>k</code></sup> ≤ |<code>n</code>|. <code>k</code> must be positive. If <code>k</code> is even, <code>n</code> must be non-negative.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-isqrt"><a href="#val-isqrt" class="anchor"></a><code><span><span class="keyword">val</span> isqrt : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>isqrt n</code> is the integer square root of <code>n</code>, provided that <code>n</code> is non‐negative. In other words, it is the greatest integer <code>r</code> such that <code>r</code>² ≤ <code>n</code>, that is, ⌊√<code>n</code>⌋. It is equivalent to <code>kth_root ~k:2 n</code> but should be faster.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-isqrt_if_square"><a href="#val-isqrt_if_square" class="anchor"></a><code><span><span class="keyword">val</span> isqrt_if_square : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>isqrt_if_square n</code> is the integer square root of <code>n</code> if <code>n</code> is a perfect square, or <code>None</code> otherwise. When <code>n</code> is not square, this is faster than combining <a href="#val-isqrt"><code>isqrt</code></a> with <a href="#val-is_square"><code>is_square</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-icbrt"><a href="#val-icbrt" class="anchor"></a><code><span><span class="keyword">val</span> icbrt : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>icbrt n</code> is the integer cube root of <code>n</code>, rounded towards zero. In other words, it is <code>sign n × r</code> where <code>r</code> is the greatest integer such that <code>r</code>³ ≤ |<code>n</code>|. It is equivalent to <code>kth_root ~k:3 n</code> but may be faster.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_kth_pow"><a href="#val-is_kth_pow" class="anchor"></a><code><span><span class="keyword">val</span> is_kth_pow : <span>k:int <span class="arrow">&#45;&gt;</span></span> <span>?root:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_kth_pow ~k ~root n</code> is true if and only if <code>n</code> = <code>root</code><sup><code>k</code></sup>. When <code>root</code> is omitted, <code>is_kth_pow n</code> says whether <code>n</code> is a <code>k</code><sup>th</sup> power. When <code>root</code> is provided, it is equivalent to <a href="#val-is_pow"><code>is_pow</code></a><code> ~base:root ~exp:k n</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_square"><a href="#val-is_square" class="anchor"></a><code><span><span class="keyword">val</span> is_square : <span>?root:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_square ~root n</code> is true if and only if <code>n</code> is the square of <code>root</code>. When <code>root</code> is omitted, <code>is_square n</code> says whether <code>n</code> is a perfect square. It is equivalent to <code>is_kth_pow ~k:2 ~root n</code> but faster.</p></div></div><h3 id="divisors-and-multiples"><a href="#divisors-and-multiples" class="anchor"></a>Divisors and multiples</h3><div class="odoc-spec"><div class="spec value anchored" id="val-is_multiple"><a href="#val-is_multiple" class="anchor"></a><code><span><span class="keyword">val</span> is_multiple : <span>of_:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_multiple ~of_:a b</code> is <code>true</code> iff <code>b</code> is a multiple of <code>a</code>. This function never raises <code>Division_by_zero</code>, but returns <code>true</code> when <code>a</code> = 0 and <code>b</code> = 0.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_even"><a href="#val-is_even" class="anchor"></a><code><span><span class="keyword">val</span> is_even : <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_even a</code> is equivalent to <code>is_multiple ~of_:2 a</code> but faster.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_odd"><a href="#val-is_odd" class="anchor"></a><code><span><span class="keyword">val</span> is_odd : <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_odd a</code> is equivalent to <code>not (is_multiple ~of_:2 a)</code> but faster.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gcd"><a href="#val-gcd" class="anchor"></a><code><span><span class="keyword">val</span> gcd : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>gcd a b</code> is the <em>positive</em> greatest common divisor of <code>a</code> and <code>b</code>. <b>Complexity:</b> 𝒪(log(min(|<code>a</code>|,|<code>b</code>|))) integer divisions.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>0 only when <code>a</code> = <code>b</code> = 0.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gcd_of_seq"><a href="#val-gcd_of_seq" class="anchor"></a><code><span><span class="keyword">val</span> gcd_of_seq : <span><span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The positive greatest common divisor of a sequence of numbers. <b>Complexity:</b> 𝒪(<i>n</i> × log(<i>m</i>)) integer divisions where <i>n</i> is the length of the sequence and <i>m</i> is its maximum element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gcdext"><a href="#val-gcdext" class="anchor"></a><code><span><span class="keyword">val</span> gcdext : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int * int * int</span></code></div><div class="spec-doc"><p><code>gcdext a b</code> is the extended Euclidean algorithm; it returns <code>(d, u, v)</code> where <code>d</code> is the <em>positive</em> greatest common divisor of <code>a</code> and <code>b</code>, and <code>u</code> and <code>v</code> are Bézout’s coefficients, such that <code>u</code>×<code>a</code> + <code>v</code>×<code>b</code> = <code>d</code>. Bézout’s coefficients <code>(u, v)</code> are defined modulo <code>(b/d, −a/d)</code>.</p><p>If <code>a</code> ≠ 0, <code>b</code> ≠ 0 and |<code>a</code>| ≠ |<code>b</code>|, then this function returns the unique pair of coefficients whose magnitude is minimal; this pair is in the following range (in particular, the function never overflows):</p><ul><li>|<code>u</code>| ≤ ½|<code>b/d</code>|</li><li>|<code>v</code>| ≤ ½|<code>a/d</code>|</li></ul><p>In the edge cases (<code>a</code> = 0 or <code>b</code> = 0 or |<code>a</code>| = |<code>b</code>|), it returns <code>(u, v)</code> = (0, 0) or (±1, 0) or (0, ±1).</p><p><b>Complexity:</b> 𝒪(log(min(|<code>a</code>|,|<code>b</code>|))) integer divisions.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>d</code> = 0 only when <code>a</code> = <code>b</code> = 0.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gcdext_of_seq"><a href="#val-gcdext_of_seq" class="anchor"></a><code><span><span class="keyword">val</span> gcdext_of_seq : <span><span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> int * <span>int list</span></span></code></div><div class="spec-doc"><p>The positive greatest common divisor of a sequence of numbers, with Bézout coefficients. <code>gcdext_of_seq @@ List.to_seq [ a1 ; … ; an ]</code> returns a pair <code>(d, [ u1 ; … ; un ])</code> such that <code>d</code> is the positive greatest common divisor of <i>a<sub>1</sub>, …, a<sub>n</sub></i>, and the <i>u<sub>i</sub></i> are coefficients such that <i>a<sub>1</sub>×u<sub>1</sub> + … + a<sub>n</sub>×u<sub>n</sub> = d</i>.</p><p><b>Complexity:</b> 𝒪(<i>n</i> × log(<i>m</i>)) integer divisions where <i>n</i> is the length of the sequence and <i>m</i> is its maximum element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the computation of Bézout’s coefficients provokes an overflow, which may happen even if there exists a representable vector of coefficients.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lcm"><a href="#val-lcm" class="anchor"></a><code><span><span class="keyword">val</span> lcm : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>lcm a b</code> is the lesser common multiple of <code>a</code> and <code>b</code>. Its sign is that of <code>a</code>×<code>b</code>. <b>Complexity:</b> 𝒪(log(min(|<code>a</code>|,|<code>b</code>|))) integer divisions.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lcm_of_seq"><a href="#val-lcm_of_seq" class="anchor"></a><code><span><span class="keyword">val</span> lcm_of_seq : <span><span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The lesser common multiple of a sequence of numbers. <b>Complexity:</b> 𝒪(<i>n</i> × log(<i>m</i>)) integer divisions where <i>n</i> is the length of the sequence and <i>m</i> is its maximum element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-valuation"><a href="#val-valuation" class="anchor"></a><code><span><span class="keyword">val</span> valuation : <span>factor:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>valuation ~factor:d n</code> returns <code>(k, m)</code> such that <code>n</code> = <code>d</code><sup><code>k</code></sup>×<code>m</code> and <code>m</code> is not divisible by <code>d</code>. This assumes that <code>n</code> is not null and that <code>d</code> is not ±1. <b>Complexity:</b> 𝒪(<code>k</code>) = 𝒪(log(<code>n</code>)) integer divisions.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>d</code> is null.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-valuation_of_2"><a href="#val-valuation_of_2" class="anchor"></a><code><span><span class="keyword">val</span> valuation_of_2 : <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>valuation_of_2</code> is equivalent to <code>valuation ~factor:2</code>, but much faster.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-smallest_root"><a href="#val-smallest_root" class="anchor"></a><code><span><span class="keyword">val</span> smallest_root : <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>smallest_root n</code> returns <code>(r, k)</code> such that <code>n</code> = <code>r</code><sup><code>k</code></sup> and |<code>r</code>| is minimal (which also implies that <code>k</code> is maximal). <code>n</code> must be non-zero.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>(1, 0) for <code>n</code> = 1, and (-1, 1) for <code>n</code> = -1.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-jacobi"><a href="#val-jacobi" class="anchor"></a><code><span><span class="keyword">val</span> jacobi : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>jacobi a n</code> is the Jacobi symbol (<code>a</code>|<code>n</code>), provided that <code>n</code> is odd and positive. <b>Complexity:</b> 𝒪(log(min(|<code>a</code>|,<code>n</code>))) integer divisions.</p></div></div><h3 id="binomial-coefficients"><a href="#binomial-coefficients" class="anchor"></a>Binomial coefficients</h3><div class="odoc-spec"><div class="spec value anchored" id="val-binoms"><a href="#val-binoms" class="anchor"></a><code><span><span class="keyword">val</span> binoms : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int array</span></span></code></div><div class="spec-doc"><p><code>binoms n</code> returns the <code>n</code><sup>th</sup> row of Pascal’s triangle, provided that <code>n</code> is a non-negative integer. <b>Complexity:</b> time 𝒪(<code>n</code>), space 𝒪(<code>n</code>).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the greatest value of the result overflows. For 64‐bit OCaml, this happens for <code>n</code> ≥ 66.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-binom"><a href="#val-binom" class="anchor"></a><code><span><span class="keyword">val</span> binom : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>binom n p</code> is the <code>p</code><sup>th</sup> element of the <code>n</code><sup>th</sup> row of Pascal’s triangle, provided that 0 ≤ <code>p</code> ≤ <code>n</code>. <b>Complexity:</b> time 𝒪(min(<code>p</code>,<code>n</code>−<code>p</code>)) = 𝒪(<code>n</code>), space 𝒪(1).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-central_binom"><a href="#val-central_binom" class="anchor"></a><code><span><span class="keyword">val</span> central_binom : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>central_binom p</code> is the <code>p</code><sup>th</sup> element of the (2×<code>p</code>)<sup>th</sup> row of Pascal’s triangle, provided that 0 ≤ <code>p</code>. <b>Complexity:</b> time 𝒪(<code>p</code>), space 𝒪(1).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows. For 64‐bit OCaml, this happens for <code>p</code> ≥ 33.</p></li></ul></div></div><h3 id="bit-manipulation"><a href="#bit-manipulation" class="anchor"></a>Bit manipulation</h3><p>Most standard bitwise functions are omitted, because it is not clear what to do with overflowing integers. One common usage, dividing or multiplying by powers of 2, is covered by other, specialized functions.</p><p>Missing functions from the standard library: <code>(land)</code> / <code>Int.logand</code>, <code>(lor)</code> / <code>Int.logor</code>, <code>(lxor)</code> / <code>Int.logxor</code>, <code>lnot</code> / <code>Int.lognot</code>, <code>(lsl)</code> / <code>Int.shift_left</code>, <code>(lsr)</code> / <code>Int.shift_right_logical</code>, <code>(asr)</code> / <code>Int.shift_right</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-number_of_bits_set"><a href="#val-number_of_bits_set" class="anchor"></a><code><span><span class="keyword">val</span> number_of_bits_set : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>number_of_bits_set n</code> is the number of non-zero bits in the binary writing of the integer <code>n</code> (assuming two’s complement for negative numbers). <b>Complexity:</b> 𝒪(<code>result</code>).</p></div></div><h3 id="randomness"><a href="#randomness" class="anchor"></a>Randomness</h3><div class="odoc-spec"><div class="spec value anchored" id="val-rand"><a href="#val-rand" class="anchor"></a><code><span><span class="keyword">val</span> rand : <span>?min:int <span class="arrow">&#45;&gt;</span></span> <span>?max:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rand ~min ~max ()</code> draws a random integer with the uniform distribution between <code>min</code> and <code>max</code> (inclusive). <code>max</code> must be greater than or equal to <code>min</code>. <code>min</code> defaults to 0, <code>max</code> defaults to <code>max_int</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rand_signed"><a href="#val-rand_signed" class="anchor"></a><code><span><span class="keyword">val</span> rand_signed : <span>?max:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rand_signed ~max ()</code> draws a random integer with the uniform distribution, with an absolute value at most <code>max</code>. <code>max</code> must be non-negative.</p></div></div><h3 id="sequences"><a href="#sequences" class="anchor"></a>Sequences</h3><div class="odoc-spec"><div class="spec value anchored" id="val-range'"><a href="#val-range'" class="anchor"></a><code><span><span class="keyword">val</span> range' : <span>?step:int <span class="arrow">&#45;&gt;</span></span> <span>?from:int <span class="arrow">&#45;&gt;</span></span> <span>?til:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>range' ~step ~from ~til ()</code> returns the sequence of integers between <code>from</code> (inclusive) and <code>til</code> (exclusive), by increments of <code>step</code>. <code>step</code> must be non-zero, but it can be negative, in which case the sequence is decreasing. <code>step</code> defaults to 1, <code>from</code> defaults to 0; when <code>til</code> is not given, the default is to build the sequence of all representable integers starting from <code>from</code> with increment <code>step</code>. The sequence is persistent (the unit argument is meaningless, it just erases optional arguments). <b>Complexity:</b> 𝒪(1) time and space.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span>from:int <span class="arrow">&#45;&gt;</span></span> <span>til:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>range ~from ~til</code> are the integers from <code>from</code> up to <code>til</code>−1. In other words it is <code>range' ~step:1 ~from ~til ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range_down"><a href="#val-range_down" class="anchor"></a><code><span><span class="keyword">val</span> range_down : <span>from:int <span class="arrow">&#45;&gt;</span></span> <span>til:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>range_down ~from ~til</code> are the integers from <code>from</code> <em>down</em> to <code>til</code>+1. In other words it is <code>range' ~step:~-1 ~from ~til ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range0"><a href="#val-range0" class="anchor"></a><code><span><span class="keyword">val</span> range0 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>range0 n</code> are the <code>n</code> integers from 0 up to <code>n</code>−1. In other words, it is <code>range ~from:0 ~til:n</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-range1"><a href="#val-range1" class="anchor"></a><code><span><span class="keyword">val</span> range1 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>range0 n</code> are the <code>n</code> integers from 1 up to <code>n</code>. In other words, it is <code>range ~from:1 ~til:(n+1)</code> (except that <code>n</code> is allowed to be <code>max_int</code>).</p></div></div><h3 id="operators"><a href="#operators" class="anchor"></a>Operators</h3><p>We deliberately override the standard operators. This is to make sure we don’t write unsafe arithmetic by accident.</p><div class="odoc-spec"><div class="spec value anchored" id="val-(~-)"><a href="#val-(~-)" class="anchor"></a><code><span><span class="keyword">val</span> (~-) : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Prefix notation for <a href="#val-opp"><code>opp</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(+)"><a href="#val-(+)" class="anchor"></a><code><span><span class="keyword">val</span> (+) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Infix notation for <a href="#val-add"><code>add</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(-)"><a href="#val-(-)" class="anchor"></a><code><span><span class="keyword">val</span> (-) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Infix notation for <a href="#val-sub"><code>sub</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(*)"><a href="#val-(*)" class="anchor"></a><code><span><span class="keyword">val</span> (*) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Infix notation for <a href="#val-mul"><code>mul</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span><span class="keyword">val</span> (/) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Infix notation for <a href="#val-div_exact"><code>div_exact</code></a>. Note that this is more restrictive than the usual division from the standard library; this forces us to realize when we are doing a non-exact division, for which we must write <a href="#val-(//)"><code>(//)</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(//)"><a href="#val-(//)" class="anchor"></a><code><span><span class="keyword">val</span> (//) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Infix notation for <a href="#val-equo"><code>equo</code></a>. Note that this is not the same as <code>Stdlib.(/)</code> when the dividend is negative.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/%)"><a href="#val-(/%)" class="anchor"></a><code><span><span class="keyword">val</span> (/%) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Infix notation for <a href="#val-erem"><code>erem</code></a>. Same remark as for <a href="#val-(//)"><code>(//)</code></a>. We don’t use <code>(%)</code> because we likely want that symbol to be available for other things (e.g. for function composition).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(mod)"><a href="#val-(mod)" class="anchor"></a><code><span><span class="keyword">val</span> (mod) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Same.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(**)"><a href="#val-(**)" class="anchor"></a><code><span><span class="keyword">val</span> (**) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Infix notation for <a href="#val-pow"><code>pow</code></a>. Note that this overrides the standard library’s notation for floating-point exponentiation. Thus we re-expose the latter with the notation <a href="#val-(**.)"><code>(**.)</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(**.)"><a href="#val-(**.)" class="anchor"></a><code><span><span class="keyword">val</span> (**.) : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>New infix notation for <code>Stdlib.( ** )</code>, the floating-point exponentiation.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Unsafe"><a href="#module-Unsafe" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Unsafe/index.html">Unsafe</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module <code>Unsafe</code> gives access to the old operations for when we know what we are doing (i.e. we know that a given operation cannot overflow) and we absolutely don’t want to pay for the overhead of the safe functions. Operators in that module are suffixed with a <code>!</code> so as to distinguish them clearly.</p></div></div></div></body></html>