<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Primes (euler.Euler.Primes)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">euler</a> &#x00BB; <a href="../index.html">Euler</a> &#x00BB; Primes</nav><header class="odoc-preamble"><h1>Module <code><span>Euler.Primes</span></code></h1><p>Prime numbers and integer factorization.</p></header><nav class="odoc-toc"><ul><li><a href="#prime-number-count">Prime number count</a></li><li><a href="#first-prime-numbers">First prime numbers</a></li><li><a href="#primality-testing">Primality testing</a></li><li><a href="#integer-factorization">Integer factorization</a></li><li><a href="#usual-functions">Usual functions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-factorization"><a href="#type-factorization" class="anchor"></a><code><span><span class="keyword">type</span> factorization</span><span> = <span><span>(int * int)</span> list</span></span></code></div><div class="spec-doc"><p>The type of the factorized form of an integer. The factorization of <code>n</code> is a list <code>[ (p1, k1) ; … ; (pℓ, kℓ) ]</code> such that <code>n</code> = <code>p1</code><sup><code>k1</code></sup> × … × <code>pℓ</code><sup><code>kℓ</code></sup> and <code>p1</code> &lt; … &lt; <code>pℓ</code> are prime.</p></div></div><h3 id="prime-number-count"><a href="#prime-number-count" class="anchor"></a>Prime number count</h3><p>The number π(x) of prime numbers less than x is asymptotically equivalent to x ∕ ln(x). It is also equivalent to li(x), where li is the <a href="https://en.wikipedia.org/wiki/Logarithmic_integral_function">logarithmic integral function</a>, which gives a much more precise estimation.</p><div class="odoc-spec"><div class="spec value anchored" id="val-li"><a href="#val-li" class="anchor"></a><code><span><span class="keyword">val</span> li : <span>?precision:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>The logarithmic integral function. It is defined only for numbers (strictly) greater than <code>1.0</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">precision</span> <p>The series summation stops as soon as the increment becomes smaller than <code>precision</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-overestimate_number_of_primes"><a href="#val-overestimate_number_of_primes" class="anchor"></a><code><span><span class="keyword">val</span> overestimate_number_of_primes : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>overestimate_number_of_primes nmax</code> gives a relatively precise upper bound on the number of prime numbers below <code>nmax</code>.</p></div></div><h3 id="first-prime-numbers"><a href="#first-prime-numbers" class="anchor"></a>First prime numbers</h3><div class="odoc-spec"><div class="spec value anchored" id="val-primes_under_100"><a href="#val-primes_under_100" class="anchor"></a><code><span><span class="keyword">val</span> primes_under_100 : <span>int array</span></span></code></div><div class="spec-doc"><p>The twenty‐five prime numbers less than 100, in ascending order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-primes_under_10_000"><a href="#val-primes_under_10_000" class="anchor"></a><code><span><span class="keyword">val</span> primes_under_10_000 : <span>int array</span></span></code></div><div class="spec-doc"><p>The prime numbers less than 10 000, in ascending order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-primes"><a href="#val-primes" class="anchor"></a><code><span><span class="keyword">val</span> primes : <span>int <span class="arrow">&#45;&gt;</span></span> <span>do_prime:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>primes nmax ~do_prime:f</code> calls <code>f</code> on all prime numbers in ascending order from 2 to <em>slightly more than</em> <code>nmax</code>, as soon as they are found. This is useful to iterate on prime numbers and stop when some condition is met. <b>Complexity:</b> time 𝒪(<code>nmax</code>×log(log(<code>nmax</code>))), space 𝒪(π(√<code>nmax</code>)) = 𝒪(√<code>nmax</code> ∕ log(<code>nmax</code>)).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-factorizing_sieve"><a href="#val-factorizing_sieve" class="anchor"></a><code><span><span class="keyword">val</span> factorizing_sieve : 
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>do_factors:<span>(<span><a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-factorization">factorization</a> array</span></span></code></div><div class="spec-doc"><p>Extended prime sieve. <code>factorizing_sieve nmax ~do_factors:f</code> computes the factorization of all numbers up to <code>nmax</code> (included). The result is an array <code>s</code> such that <code>s.(n)</code> is the factorization of <code>n</code>. The function also calls <code>f</code> on the factorization of each number from 2 to <code>nmax</code>, in order. This is useful to iterate on the factorized form of (small) numbers and stop when some condition is met. Note that this is costly both in time and in space, so <code>nmax</code> is bridled with an internal upper bound. <b>Complexity:</b> time 𝒪(<code>nmax</code>×log(log(<code>nmax</code>))), space 𝒪(<code>nmax</code>×log(log(<code>nmax</code>))).</p></div></div><h3 id="primality-testing"><a href="#primality-testing" class="anchor"></a>Primality testing</h3><div class="odoc-spec"><div class="spec value anchored" id="val-is_prime"><a href="#val-is_prime" class="anchor"></a><code><span><span class="keyword">val</span> is_prime : <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Primality test. <code>is_prime n</code> is true if and only if <code>n</code> is a prime number. Note that this is a deterministic test. <b>Complexity:</b> 𝒪(fast).</p></div></div><h3 id="integer-factorization"><a href="#integer-factorization" class="anchor"></a>Integer factorization</h3><div class="odoc-spec"><div class="spec value anchored" id="val-factors"><a href="#val-factors" class="anchor"></a><code><span><span class="keyword">val</span> factors : <span>?tries:int <span class="arrow">&#45;&gt;</span></span> <span>?max_fact:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-factorization">factorization</a></span></code></div><div class="spec-doc"><p>Integer factorization. This uses Lenstra’s elliptic‐curve algorithm for finding factors (as of 2018, it is the most efficient known algorithm for 64‐bit numbers). <b>Complexity:</b> 𝒪(terrible).</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">tries</span> <p>The number of elliptic curves to try before resigning.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_fact</span> <p>The “small exponents” tried by Lenstra’s algorithm are the factorial numbers up to the factorial of <code>max_fact</code>.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the prime factorization of the given number. It may contain non‐prime factors <code>d</code>, if their factorization failed within the allowed time; this is signaled by negating their value, as in <code>(−d, 1)</code>. This is highly unlikely with default parameters.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Assert_failure</span> <p>when the number to factorize is not positive.</p></li></ul></div></div><h3 id="usual-functions"><a href="#usual-functions" class="anchor"></a>Usual functions</h3><p>Some functions defined in this section can be computed efficiently when the factorization of their argument is known. Hence they take an optional argument <code>?factors</code> which is expected to be the factorization of their main argument. If absent, those functions resort to computing the factorization themselves, or another inefficient algorithm.</p><div class="odoc-spec"><div class="spec value anchored" id="val-eulerphi"><a href="#val-eulerphi" class="anchor"></a><code><span><span class="keyword">val</span> eulerphi : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Euler’s totient function. <code>eulerphi n</code>, often noted φ(<code>n</code>), is the number of integers between 1 and <code>n</code> which are coprime with <code>n</code>, provided that <code>n</code> is positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eulerphi_from_file"><a href="#val-eulerphi_from_file" class="anchor"></a><code><span><span class="keyword">val</span> eulerphi_from_file : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int array</span></span></code></div><div class="spec-doc"><p><code>eulerphi_from_file nmax</code> loads precomputed values of φ from a file on disk.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>an array <code>phi</code> such that <code>phi.(n)</code> = φ(<code>n</code>) for all 1 ≤ <code>n</code> ≤ <code>nmax</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-number_of_divisors"><a href="#val-number_of_divisors" class="anchor"></a><code><span><span class="keyword">val</span> number_of_divisors : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>number_of_divisors n</code> is the number of divisors of <code>n</code> (including 1 and <code>n</code> itself), provided that <code>n</code> is positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-divisors"><a href="#val-divisors" class="anchor"></a><code><span><span class="keyword">val</span> divisors : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p><code>divisors n</code> is the list of all divisors of <code>n</code> (including 1 and <code>n</code> itself) in ascending order, provided that <code>n</code> is positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_divisor_pairs"><a href="#val-gen_divisor_pairs" class="anchor"></a><code><span><span class="keyword">val</span> gen_divisor_pairs : 
  <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int * int)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>gen_divisor_pairs n</code> returns all pairs (d, <code>n</code>/d) where d divides <code>n</code> and 1 ≤ d ≤ √<code>n</code>, provided that <code>n</code> is positive. Pairs are presented in ascending order of d. When <code>n</code> is a perfect square, the pair (√<code>n</code>, √<code>n</code>) is presented only once.</p></div></div></div></body></html>