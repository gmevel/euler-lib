<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Primes (euler.Euler.Primes)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../index.html">euler</a> &#x00BB; <a href="../index.html">Euler</a> &#x00BB; Primes</nav><header class="odoc-preamble"><h1>Module <code><span>Euler.Primes</span></code></h1><p>Prime numbers and integer factorization.</p></header><nav class="odoc-toc"><ul><li><a href="#prime-number-count">Prime number count</a></li><li><a href="#first-prime-numbers">First prime numbers</a></li><li><a href="#primality-testing">Primality testing</a></li><li><a href="#integer-factorization">Integer factorization</a></li><li><a href="#usual-functions">Usual functions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-factorization"><a href="#type-factorization" class="anchor"></a><code><span><span class="keyword">type</span> factorization</span><span> = <span><span>(int * int)</span> list</span></span></code></div><div class="spec-doc"><p>The type of the factorized form of an integer. The factorization of <code>n</code> is a list <code>[ (p1, k1) ; ‚Ä¶ ; (p‚Ñì, k‚Ñì) ]</code> such that <code>n</code> = <code>p1</code><sup><code>k1</code></sup> √ó ‚Ä¶ √ó <code>p‚Ñì</code><sup><code>k‚Ñì</code></sup> and <code>p1</code> &lt; ‚Ä¶ &lt; <code>p‚Ñì</code> are prime.</p></div></div><h3 id="prime-number-count"><a href="#prime-number-count" class="anchor"></a>Prime number count</h3><p>The number œÄ(<i>x</i>) of prime numbers less than x is asymptotically equivalent to <i>x</i> ‚àï ln(<i>x</i>). It is also equivalent to li(x), where li is the <a href="https://en.wikipedia.org/wiki/Logarithmic_integral_function">logarithmic integral function</a>, which gives a much more precise estimation.</p><div class="odoc-spec"><div class="spec value anchored" id="val-li"><a href="#val-li" class="anchor"></a><code><span><span class="keyword">val</span> li : <span>?precision:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>The logarithmic integral function. It is defined only for numbers (strictly) greater than <code>1.0</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">precision</span> <p>The series summation stops as soon as the increment becomes smaller than <code>precision</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-overestimate_number_of_primes"><a href="#val-overestimate_number_of_primes" class="anchor"></a><code><span><span class="keyword">val</span> overestimate_number_of_primes : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>overestimate_number_of_primes nmax</code> gives a relatively precise upper bound on the number of prime numbers below <code>nmax</code>.</p></div></div><h3 id="first-prime-numbers"><a href="#first-prime-numbers" class="anchor"></a>First prime numbers</h3><div class="odoc-spec"><div class="spec value anchored" id="val-primes_under_100"><a href="#val-primes_under_100" class="anchor"></a><code><span><span class="keyword">val</span> primes_under_100 : <span>int array</span></span></code></div><div class="spec-doc"><p>The twenty‚Äêfive prime numbers less than 100, in ascending order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-primes_under_10_000"><a href="#val-primes_under_10_000" class="anchor"></a><code><span><span class="keyword">val</span> primes_under_10_000 : <span>int array</span></span></code></div><div class="spec-doc"><p>The prime numbers less than 10‚ÄØ000, in ascending order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_primes"><a href="#val-iter_primes" class="anchor"></a><code><span><span class="keyword">val</span> iter_primes : <span>int <span class="arrow">&#45;&gt;</span></span> <span>do_prime:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_primes nmax ~do_prime:f</code> calls <code>f</code> on all prime numbers in ascending order from 2 to <em>slightly more than</em> <code>nmax</code>, as soon as they are found. This is useful to iterate on prime numbers and stop when some condition is met. <b>Complexity:</b> time ùí™(<code>nmax</code>√ólog(log(<code>nmax</code>))), space ùí™(œÄ(‚àö<code>nmax</code>)) = ùí™(‚àö<code>nmax</code>‚ÄØ‚àï‚ÄØlog(<code>nmax</code>)).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_primes"><a href="#val-gen_primes" class="anchor"></a><code><span><span class="keyword">val</span> gen_primes : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>The sequence of prime numbers up to a specified bound. This is significantly slower than <a href="#val-iter_primes"><code>iter_primes</code></a> (about 50¬†times slower for <code>nmax = 1_000_000_000</code>), but has the advantage that advancing through the sequence is controlled by the consumer, This is a purely functional algorithm, hence the produced sequence is persistent. <b>Complexity:</b> time ùí™(<code>nmax</code>√ólog(<code>nmax</code>)√ólog(log(<code>nmax</code>))), space ùí™(‚àö<code>nmax</code>‚ÄØ‚àï‚ÄØlog(<code>nmax</code>)).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-factorizing_sieve"><a href="#val-factorizing_sieve" class="anchor"></a><code><span><span class="keyword">val</span> factorizing_sieve : 
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>do_factors:<span>(<span><a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-factorization">factorization</a> array</span></span></code></div><div class="spec-doc"><p>Extended prime sieve. <code>factorizing_sieve nmax ~do_factors:f</code> computes the factorization of all numbers up to <code>nmax</code> (included). The result is an array <code>s</code> such that <code>s.(n)</code> is the factorization of <code>n</code>. The function also calls <code>f</code> on the factorization of each number from 2 to <code>nmax</code>, in order. This is useful to iterate on the factorized form of (small) numbers and stop when some condition is met. Note that this is costly both in time and in space, so <code>nmax</code> is bridled with an internal upper bound. <b>Complexity:</b> time ùí™(<code>nmax</code>√ólog(log(<code>nmax</code>))), space ùí™(<code>nmax</code>√ólog(log(<code>nmax</code>))).</p></div></div><h3 id="primality-testing"><a href="#primality-testing" class="anchor"></a>Primality testing</h3><div class="odoc-spec"><div class="spec value anchored" id="val-is_prime"><a href="#val-is_prime" class="anchor"></a><code><span><span class="keyword">val</span> is_prime : <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Primality test. <code>is_prime n</code> is true if and only if <code>n</code> is a prime number. Note that this is a deterministic test. <b>Complexity:</b> ùí™(fast).</p></div></div><h3 id="integer-factorization"><a href="#integer-factorization" class="anchor"></a>Integer factorization</h3><div class="odoc-spec"><div class="spec value anchored" id="val-factors"><a href="#val-factors" class="anchor"></a><code><span><span class="keyword">val</span> factors : <span>?tries:int <span class="arrow">&#45;&gt;</span></span> <span>?max_fact:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-factorization">factorization</a></span></code></div><div class="spec-doc"><p>Integer factorization. This uses Lenstra‚Äôs elliptic‚Äêcurve algorithm for finding factors (as of 2018, it is the most efficient known algorithm for 64‚Äêbit numbers). <b>Complexity:</b> ùí™(terrible).</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">tries</span> <p>The number of elliptic curves to try before resigning.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_fact</span> <p>The ‚Äúsmall exponents‚Äù tried by Lenstra‚Äôs algorithm are the factorial numbers up to the factorial of <code>max_fact</code>.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the prime factorization of the given number. It may contain non‚Äêprime factors <code>d</code>, if their factorization failed within the allowed time; this is signaled by negating their value, as in <code>(‚àíd, 1)</code>. This is highly unlikely with default parameters.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Assert_failure</span> <p>when the number to factorize is not positive.</p></li></ul></div></div><h3 id="usual-functions"><a href="#usual-functions" class="anchor"></a>Usual functions</h3><p>Some functions defined in this section can be computed efficiently when the factorization of their argument is known. Hence they take an optional argument <code>?factors</code> which is expected to be the factorization of their main argument. If absent, those functions resort to computing the factorization themselves, or another inefficient algorithm.</p><div class="odoc-spec"><div class="spec value anchored" id="val-number_of_divisors"><a href="#val-number_of_divisors" class="anchor"></a><code><span><span class="keyword">val</span> number_of_divisors : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>number_of_divisors n</code> is the number of divisors of <code>n</code> (including 1 and <code>n</code> itself), provided that <code>n</code> is positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sum_of_divisors"><a href="#val-sum_of_divisors" class="anchor"></a><code><span><span class="keyword">val</span> sum_of_divisors : <span>?k:int <span class="arrow">&#45;&gt;</span></span> <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><a href="https://en.wikipedia.org/wiki/Divisor_function">Divisor sum</a>. <code>sum_of_divisors ~k n</code>, often noted œÉ<sub><code>k</code></sub>(<code>n</code>), is the sum of the <code>k</code>-th powers of all the divisors of <code>n</code> (including 1 and <code>n</code> itself), provided that <code>k</code> is non-negative and <code>n</code> is positive. In particular, for <code>k</code> = 0 it gives the number of divisors, and for <code>k</code> = 1 it gives the sum of the divisors. The default value of <code>k</code> is 1.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-divisors"><a href="#val-divisors" class="anchor"></a><code><span><span class="keyword">val</span> divisors : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p><code>divisors n</code> is the list of all divisors of <code>n</code> (including 1 and <code>n</code> itself) in ascending order, provided that <code>n</code> is positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-divisor_pairs"><a href="#val-divisor_pairs" class="anchor"></a><code><span><span class="keyword">val</span> divisor_pairs : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(int * int)</span> list</span></span></code></div><div class="spec-doc"><p><code>divisor_pairs n</code> is the list of all pairs (<i>d</i>, <code>n</code>/<i>d</i>) where d divides <code>n</code> and 1 ‚â§ <i>d</i> ‚â§ ‚àö<code>n</code>, provided that <code>n</code> is positive. Pairs are presented in ascending order of <i>d</i>. When <code>n</code> is a perfect square, the pair (‚àö<code>n</code>, ‚àö<code>n</code>) is presented once.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_divisor_pairs"><a href="#val-gen_divisor_pairs" class="anchor"></a><code><span><span class="keyword">val</span> gen_divisor_pairs : 
  <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int * int)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-divisor_pairs"><code>divisor_pairs</code></a> but returns a <code>Seq.t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eulerphi"><a href="#val-eulerphi" class="anchor"></a><code><span><span class="keyword">val</span> eulerphi : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler‚Äôs totient function</a>. <code>eulerphi n</code>, often noted œÜ(<code>n</code>), is the number of integers between 1 and <code>n</code> which are coprime with <code>n</code>, provided that <code>n</code> is positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eulerphi_from_file"><a href="#val-eulerphi_from_file" class="anchor"></a><code><span><span class="keyword">val</span> eulerphi_from_file : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int array</span></span></code></div><div class="spec-doc"><p><code>eulerphi_from_file nmax</code> loads precomputed values of œÜ from a file on disk.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>an array <code>phi</code> such that <code>phi.(n)</code> = œÜ(<code>n</code>) for all 1 ‚â§ <code>n</code> ‚â§ <code>nmax</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-jordan"><a href="#val-jordan" class="anchor"></a><code><span><span class="keyword">val</span> jordan : <span>k:int <span class="arrow">&#45;&gt;</span></span> <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><a href="https://en.wikipedia.org/wiki/Jordan%27s_totient_function">Jordan‚Äôs totient function</a>. <code>jordan ~k n</code>, often noted J<sub><code>k</code></sub>(<code>n</code>), is the number of <code>k</code>-tuples (<i>a<sub>1</sub>, ‚Ä¶, a</i><sub><code>k</code></sub>) such that every <i>a<sub>i</sub></i> is between 1 and <code>n</code>, and gcd(<i>a<sub>1</sub>, ‚Ä¶, a</i><sub><code>k</code></sub>, <code>n</code>) = 1 (in other words, the tuple is setwise-coprime with <code>n</code>, but not necessarily pairwise-coprime). This is a generalization of Euler‚Äôs totient, which is obtained with <code>k</code> = 1. It requires that <code>k</code> and <code>n</code> are positive.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-carmichael"><a href="#val-carmichael" class="anchor"></a><code><span><span class="keyword">val</span> carmichael : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><a href="https://en.wikipedia.org/wiki/Carmichael_function">Carmichael‚Äôs function</a>. <code>carmichael n</code>, often noted Œª(<code>n</code>), is the smallest positive exponent <i>k</i> such that, for all <i>a</i> coprime with <code>n</code>, we have <i>a<sup>k</sup></i> ‚â° 1 (mod <code>n</code>). In other words, it is the exponent of the multiplicative group of integers modulo <code>n</code>, that is, the least common multiple of the orders of all the invertible integers modulo <code>n</code>. It divides Euler‚Äôs totient but may be strictly smaller than it. This function requires that <code>n</code> is positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mobius"><a href="#val-mobius" class="anchor"></a><code><span><span class="keyword">val</span> mobius : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><a href="https://en.wikipedia.org/wiki/M√∂bius_function">M√∂bius‚Äô function</a>. <code>mobius n</code>, often noted Œº(<code>n</code>), is 0 if <code>n</code> has a square factor, ‚àí1 if <code>n</code> has an odd number of prime factors, or +1 if <code>n</code> has an even number of prime factors. This function requires that <code>n</code> is positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-derivative"><a href="#val-derivative" class="anchor"></a><code><span><span class="keyword">val</span> derivative : <span>?factors:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><a href="https://en.wikipedia.org/wiki/Arithmetic_derivative">Arithmetic derivative</a> of an integer. <code>derivative n</code>, often noted D(<code>n</code>), is such that D(0) = 0, D(‚àí1) = ‚àí1, D(<i>p</i>) = 1 for all primes <i>p</i>, and D(<i>m√ón</i>) = D(<i>m</i>)√ó<i>n</i> + <i>m</i>√óD(<i>n</i>) for all integers <i>m, n</i>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Overflow</span> <p>when the result overflows.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-order"><a href="#val-order" class="anchor"></a><code><span><span class="keyword">val</span> order : 
  <span>?factors_pred_primes:<span><a href="#type-factorization">factorization</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?factors_mod:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span>
  <span>modulo:int <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  int</span></code></div><div class="spec-doc"><p><code>order ~modulo:m a</code>, where <code>m</code> ‚â† 0, is the multiplicative order of <code>a</code> modulo <code>m</code>, This is the smallest positive exponent <i>n</i> such that <code>a</code><sup><i>n</i></sup> ‚â° 1 (mod <code>m</code>).</p><p>If given, <code>factors_mod</code> must be the factorization of <code>m</code>.</p><p>If given, <code>factors_pred_primes</code> must be the factorizations of all the <code>p</code>‚àí1 where <code>p</code> are the prime factors of <code>m</code>, sorted by <code>p</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>a</code> is not invertible modulo <code>m</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-order_with_known_multiple"><a href="#val-order_with_known_multiple" class="anchor"></a><code><span><span class="keyword">val</span> order_with_known_multiple : 
  <span>?factors_phi:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span>
  <span>phi:int <span class="arrow">&#45;&gt;</span></span>
  <span>modulo:int <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  int</span></code></div><div class="spec-doc"><p><code>order_with_known_multiple ~phi ~modulo:m a</code> is the same as <a href="#val-order"><code>order</code></a><code> ~modulo:m a</code>, but exploits the fact that the order is a divisor of <code>phi</code>. Values suitable for <code>phi</code> always include Œª(<code>m</code>) (<a href="#val-carmichael"><code>carmichael</code></a><code> m</code>) and œÜ(<code>m</code>) (<a href="#val-eulerphi"><code>eulerphi</code></a><code> m</code>); in some situations, a smaller value may be known.</p><p>If given, <code>factors_phi</code> must be the factorization of <code>phi</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>a</code> is not invertible modulo <code>m</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-order_mod_prime_pow"><a href="#val-order_mod_prime_pow" class="anchor"></a><code><span><span class="keyword">val</span> order_mod_prime_pow : 
  <span>?factors_pred_prime:<a href="#type-factorization">factorization</a> <span class="arrow">&#45;&gt;</span></span>
  <span>modulo:<span>(int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  int</span></code></div><div class="spec-doc"><p><code>order_mod_prime_pow ~modulo:(p, k) a</code>, where <code>p</code> is a prime and <code>k</code> &gt; 0, is the multiplicative order of <code>a</code> modulo <code>p</code><sup><code>k</code></sup>, It is assumed that <code>p</code><sup><code>k</code></sup> does not overflow.</p><p>If given, <code>factors_pred_prime</code> must be the factorization of <code>p</code>‚àí1.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>a</code> is not invertible modulo <code>m</code>.</p></li></ul></div></div></div></body></html>