<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Modular (euler.Euler.Modular)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">euler</a> &#x00BB; <a href="../index.html">Euler</a> &#x00BB; Modular</nav><header class="odoc-preamble"><h1>Module <code><span>Euler.Modular</span></code></h1><p>Modular arithmetic.</p><p>This module defines modular arithmetic operations, that is, operations on elements of the ring ℤ∕<i>m</i>ℤ where <i>m</i> is a positive integer, called the modulus. All operations take <i>m</i> as a named parameter <code>~modulo</code>. Elements of ℤ∕<i>m</i>ℤ are represented by their canonical representatives between 0 and <i>m</i>−1 (included), of type <code>int</code>. All functions may assume that the modulus is positive and that canonical representatives are used, and may raise <code>Assert_failure</code> if that is not the case.</p><p>The modulus can also be set globally, and not repeated for each individual operation, by giving it as a parameter to the functor <a href="Make/index.html"><code>Make</code></a>. This provides unary and binary operators.</p><p>A related function, <a href="../Primes/index.html#val-order"><code>Primes.order</code></a>, which computes the multiplicative order modulo <i>m</i>, is found in module <code>Primes</code>, because it depends on computing integer factorizations.</p></header><nav class="odoc-toc"><ul><li><a href="#functorial-interface">Functorial interface</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-opp"><a href="#val-opp" class="anchor"></a><code><span><span class="keyword">val</span> opp : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Modular opposite. <code>opp ~modulo:m a</code> is the unique element <code>a'</code> of ℤ∕<code>m</code>ℤ such that <code>a'</code>+<code>a</code> = 0.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inv"><a href="#val-inv" class="anchor"></a><code><span><span class="keyword">val</span> inv : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Modular inverse. <code>inv ~modulo:m a</code> is the unique element <code>a'</code> of ℤ∕<code>m</code>ℤ such that <code>a'</code>×<code>a</code> = 1, if it exists. <b>Complexity:</b> 𝒪(log(<code>a</code>)) = 𝒪(log(<code>m</code>)) (<code>a</code> being under canonical form).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>a</code> is not invertible.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Modular addition.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Modular subtraction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span><span class="keyword">val</span> mul : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Modular multiplication. <b>Complexity:</b> 𝒪(log(min(<code>a</code>,<code>b</code>))) = 𝒪(log(<code>m</code>)) (<code>a</code> and <code>b</code> being under canonical forms).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-div"><a href="#val-div" class="anchor"></a><code><span><span class="keyword">val</span> div : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Modular division. <code>div ~modulo:m a b</code> is the unique element <code>c</code> of ℤ∕<code>m</code>ℤ such that <code>c</code>×<code>b</code> = <code>a</code>, if it exists. <b>Complexity:</b> 𝒪(log(<code>b</code>)) = 𝒪(log(<code>m</code>)) (<code>b</code> being under canonical form).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>b</code> is not invertible.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-div_nonunique"><a href="#val-div_nonunique" class="anchor"></a><code><span><span class="keyword">val</span> div_nonunique : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>A more general modular division, which does not assume its right operand to be invertible. <code>div_nonunique ~modulo:m a b</code> is an element <code>c</code> such that <code>c</code>×<code>b</code> = <code>a</code>, if there exists one. There exists such an element iff <code>a</code> is a multiple of gcd(<code>m</code>, <code>b</code>), in which case the result is defined modulo <code>m</code> ∕ gcd(<code>m</code>, <code>b</code>); it is unique only when <code>b</code> is invertible. For example, modulo 10, 3×4 = 8×4 = 2, so 2 divided by 4 may be 3 or 8 (this example shows that the division 2 ∕ 4 cannot be simplified to 1 ∕ 2). <b>Complexity:</b> 𝒪(log(<code>b</code>)) = 𝒪(log(<code>m</code>)) (<code>b</code> being under canonical form).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when there is no such element.</p></li></ul></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Factor_found"><a href="#exception-Factor_found" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Factor_found</span> <span class="keyword">of</span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inv_factorize"><a href="#val-inv_factorize" class="anchor"></a><code><span><span class="keyword">val</span> inv_factorize : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>A version of the modular inverse specialized for factorization purposes. <code>inv_factorize ~modulo:m a</code> is similar to <code>inv ~modulo:m a</code> but handles more precisely the cases when <code>a</code> is not invertible. <b>Complexity:</b> 𝒪(log(<code>a</code>)) = 𝒪(log(<code>m</code>)) (<code>a</code> being under canonical form).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>a</code> is zero.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Factor_found</span> <p>when <code>a</code> is non‐zero and not invertible; in this case, gcd(<code>m</code>,<code>a</code>) is a non‐trivial factor of <code>m</code>, which is returned as the parameter of the exception <code>Factor_found</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pow"><a href="#val-pow" class="anchor"></a><code><span><span class="keyword">val</span> pow : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Modular exponentiation. When <code>n</code> is non‐negative, <code>pow ~modulo:m a n</code> is <code>a</code><sup><code>n</code></sup> in the ring ℤ∕<code>m</code>ℤ; when <code>n</code> is negative, it is <code>a'</code><sup>−<code>n</code></sup> where <code>a'</code> is the modular inverse of <code>a</code>. <b>Complexity:</b> 𝒪(log(<code>m</code>)×log(|<code>n</code>|)).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Division_by_zero</span> <p>when <code>n</code> is negative and <code>a</code> is not invertible.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rand"><a href="#val-rand" class="anchor"></a><code><span><span class="keyword">val</span> rand : <span>modulo:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rand ~modulo:m ()</code> draws a random element of the ring ℤ∕<code>m</code>ℤ, with the uniform distribution.</p></div></div><h3 id="functorial-interface"><a href="#functorial-interface" class="anchor"></a>Functorial interface</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-_/index.html">_</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The functor application <code>Make (M)</code> defines modular arithmetic operations with a fixed, non‐zero modulus <code>M.modulo</code>. Because the modulus needs not be repeated for each individual operation, meaningful unary and binary operators can be defined. Operations in the resulting module follow the same specifications as those in module <a href="#"><code>Modular</code></a>, with respect to return values, exceptions raised, and time costs.</p></div></div></div></body></html>